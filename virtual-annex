#!/usr/bin/env python3

import sys
import subprocess as sp
from pathlib import Path

def print_usage():
    print(f"usage: {sys.argv[0]} <directory to form links in> <reference annex repo>")

def get_remotes(annex_path):
    remotes = {}
    remotes['here'] = annex_path
    res = sp.run(['git', 'remote'], cwd=annex_path, capture_output=True, encoding='utf-8')
    remote_names = res.stdout.strip().splitlines();
    for name in remote_names:
        remotes[name] = Path(sp.run(['git', 'remote', 'get-url', name], cwd=annex_path, capture_output=True, encoding='utf-8').stdout.strip())
    return remotes

"""
Returns a map of annex file paths to a list of remotes
It is the job of the caller to find the best remote
"""
def generate_file_map(annex_path, remotes):
    listlines = sp.run(['git', 'annex', 'list'], cwd=annex_path, capture_output=True, encoding='utf-8').stdout.strip().splitlines()

    # slice the list based on whether it has the remotes or files
    i = 0
    for l in listlines:
        if l.count('|') == len(l):
            break
        i += 1

    remote_lines = listlines[1:i]
    file_lines = listlines[i+1:]

    # create a map of indicies of the list to remotes
    # here is the 0th line
    index_map = {0: 'here'}
    i = 1
    for l in remote_lines:
        remote = l.strip('|')
        # only use the ones we've specified
        if remote in remotes:
            index_map[i] = remote
        i += 1

    # go through file list and see where each file is present
    # generate a map of files
    file_map = {}
    for l in file_lines:
        # split at first space; file paths may contain their own spaces
        status, file = l.split(' ', 1)
        remotes = []
        for index, remote in index_map.items():
            if status[index] == 'X':
                remotes.append(remote)
        file_map[file] = remotes

    return file_map

def get_ranking():
    ranking = ['here']
    try:
        ranking_path = Path.home()/'.config/annex-link/ranking'
        with open(ranking_path, 'r') as f:
            for l in f.readlines():
                ranking.append(l.strip())
    except FileNotFoundError as e:
        pass
    return ranking

"""
For a file map, remotes, and ranking, return a map of
annex files to the particular remote's link
"""
def get_link_map(annex_path, remotes, ranking, file_map):
    link_map = {}
    # see if the highest ranking remote is a location of the file
    for file, loc in file_map.items():
        found = False
        for r in ranking:
            if r in loc:
                link_map[file] = remotes[r]/file
                found = True
                break
        if not found:
            print(f"File {file} not owned by any remote!")
            return None

    return link_map

def link_annexes(target_dir, link_map):
    for file, source_path in link_map.items():
        link_path = target_dir/file
        link_path.parent.mkdir(parents=True, exist_ok=True)

        if not link_path.exists():
            link_path.symlink_to(source_path)
        else:
            # if it already exists replace if the target is different
            if link_path.resolve() != source_path.resolve():
                # if it exists, we need to update it
                # the tmp link is to avoid any races
                tmp_path = link_path.parent / (link_path.name + '.tmp')
                tmp_path.symlink_to(source_path)
                tmp_path.replace(link_path)

def main():
    if len(sys.argv) < 3:
        print("Not enough arguments")
        print_usage()
        exit(1)
    target_dir = Path(sys.argv[1])
    annex_path = Path(sys.argv[2])

    remotes = get_remotes(annex_path)
    file_map = generate_file_map(annex_path, remotes)
    ranking = get_ranking()
    link_map = get_link_map(annex_path, remotes, ranking, file_map)
    link_annexes(target_dir, link_map)

if __name__ == '__main__':
    main()
